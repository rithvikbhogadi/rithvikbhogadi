\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 1 Solution}
\author{Rithvik Bhogadi and bhogadic}
\date{\today}

\begin {document}

\maketitle

This report discusses testing of the \verb|ComplexT| and \verb|TriangleT|
classes written for Assignment 1. It also discusses testing of the partner's
version of the two classes. The design restrictions for the assignment
are critiqued and then various related discussion questions are answered.

\section{Assumptions and Exceptions} \label{AssumptAndExcept}

While creating both modules named ComplexT and TriangleT, some assumptions were made on behalf of the author regarding what input will be used while testing
the methods within the module. For example, an assumption that was made while creating the $get_r$ method within the ComplexT module states that irrelevant of
the input, the method will always output the result by rounding to two decimal places. This assumption was made to prevent the method from having a longer
run time as well as an attempt to reduce the number of decimal places of the result. A very identical assumption was made regarding the $get_phi$ method
within the ComplexT module as well. This assumption was made to prevent the method from having a longer run time as well reduce the number of decimal places.

An assumption was made while creating the sqrt method within the ComplexT module. This assumption states that a non-zero value will be used as input while
testing. This is because of the fact that the method is unable to find the square root of a negative number. This will prevent the program from running into
errors at the run time and allow the program to run smooth. An assumption was made during the creation of the $tri_type$ method within the TriangleT module.
This assumption was regarding the fact that the method would only return a single unique type for the valid triangle rather than multiple types due to this
method preferring the triangle of right angle type more than the other types. This would mean that irrelevant of the input or how many types of triangle a
triangle was to satisfy, if the triangle was a right angle triangle, it would only return that the triangle was to be a right angle triangle.

\section{Test Cases and Rationale} \label{Testing}
The test cases were made for the ComplexT and TriangleT module for which in each test case a specified result would have had to been met in order for the
test to have passed. Test cases for each method were made in order to ensure all parts of code of every method were tested. While creating the test cases,
each part of the code was made to ensure that the methods were robust and fully working while taking into consideration that a couple of assumptions had to
be made. The results of all the test cases have been affirmative and guarantee a full working method while taking into consideration the assumptions that
were made. For example, while creating a test case for $get_sides$ method within the TriangleT module, the test case had made sure to firstly check whether
any one side of the triangle is less than zero. This is in order to check if the triangle is a valid triangle or not and allow for the $get_sides$ method to
work. A test case made for the $perim$ method within the TriangleT module consisted of firstly checking whether the perimeter of the triangle would be less
than zero. This is important to check because if the triangle was to have a perimeter less than zero, it would mean that the triangle is not valid and that
it would have failed the test. Therefore, it is important to check that the triangle does not have a perimeter less than 0.

\section{Results of Testing Partner's Code}
When running the partner`s code, there were some complications while testing a few methods. For example, while attempting to test the $conj$, $recip$ and
$sqrt$ method from the ComplexT module of the partner`s code, all of the tests had shown the same error. This error was regarding the fact that
$test_driver.py$ file used did not implement "numpy" under the assumption that it was not needed in order to successfully implement a method. When running the
test on the $is_valid$ method within the TriangleT module of the partner`s code, the method had failed to accomplish the task. This was because the partner
had not made sure to check whether all of the sides of the triangle had lengths greater than zero. Due to not ensuring this, the method had failed the test
case written for that method.

\section{Critique of Given Design Specification}

The assignment specifications were straightforward and clear. One of the specifications to admire in regards to this assignment was about the creation of
modules such as ComplexT and TriangleT. The reason I say this is due to the assignment giving us an experience in which we able to create multiple methods
in order to complete a task. This is great experience for us as we not only better our skills typing in python but learn on how to better our code by doing
repetitive commits and testing. This allows us to look back and reflect on previous drafts of our code. The assignment specification required us to create a
$test_driver.py$ file which allowed us to create our own test cases to test our methods. This was highly beneficial as it gave us a taste of what the
professional workplace would operate like. By creating our own test cases, it allowed for us to apply our intuition in order to change the method to make it
more robust and successful.

Although there were not many flaws regarding the assignment specifications, a drawback would be that there were too many ambiguities involved within this
assignment which causes many students including myself to assume a lot. Although the assignment was as clear as possible, it would have been nice to be a
bit more clear when in regards to creating some methods. This would only improve the quality of code produced by the students. This can implemented within
the design by following how other method specifications have been outlined. This can be done by asking for a certain number of mandatory implementations and
then asking for a mandatory output. This would allow for the student to be more focused on accomplishing the task rather than having to assume.

\section{Answers to Questions}

\begin{enumerate}[(a)]

\item From the ComplexT module, the selectors are "real", "imag", $get_r$, $get_phi$, "conj", "recip", "sqrt". From the TriangleT module, the selectors are
$get_sides$, "perim", "area", $is_valid$, $tri_type$.

\item For the ComplexT module, the two possible state variables are the "real" and "imag" method. For the TriangleT module, the two possible state variables
are the $init$ method and the $tri_type$ method.

\item In regards to creating two additional methods within the ComplexT module, it would not make sense to create such methods as it is mathematically
impossible to determine whether or not a complex number is greater than or less than the other. Although it is possible to determine whether two complex
numbers are equal to each other or not, this does not signal that by changing the specifications of the "equal" method that this would allow for the program
to determine which complex number is greater than or less than the other.

\item In order to check whether a triangle is valid or not within the TriangleT module in regards to the $is_valid$ method we are able to figure out which
triangle is valid and which ones aren`t valid. This is done by firstly checking to see whether all of the three lengths of the triangle are positive
integers greater than zero. This is because it is impossible for any one of the sides of a triangle to have length of zero or below. If a sample triangle
were to pass the first condition then it must check to see whether the addition of any two side of the triangle are greater than the third side. This is a
very fundamental rule in creating a valid triangle. If these conditions were to be met then the sample triangle would be considered a valid triangle.
Secondly, if a triangle was not valid, then the $is_valid$ method would return false.

\item It would not be a good idea to have state variable that stores the type of triangle within the $tri_type$ method because there can be the possibility
of a triangle fulfilling the requirements to be a triangle of two types. For example, a triangle can be both scalene and right angle triangle. A new
variable within the constructor method might not be able to be assigned two types of triangle within one variable. Therefore, it would not be a good idea.

\item The performance of a product depends upon the qualities such as speed, storage and efficiency. Efficiency depends upon the ability to use computer
resources such as memory, time and communication. Hench if the product is not very effiecient it affects the performance as well. The usability of a
software product depends on how easy it would be to use that software product. The usability of the software product depends on the capabilities and
preferences of the user. Although this were true, if the performance of the product is not good, it adversely affects the usability of the product.

\item At times although using a rational design process to provide documentation to clients or reviewers maybe be beneficial in order to produce quality
software, there are times when it is not neccessary to "fake" the rational design process. For example, if a software developer were developing software for
themselves and not for any client or reviewer, then the developer would not have to provide documentation in order to make it seem as of they had followed a
rational process. Another example when it is not neccessary to "fake" a rational design process is if there is very small implementation.

\item The reusability of a component from a software may affect the reliability of a product in two different ways. For example, if the product from which a
component had been reused from had flaws within it, then the code that would have been reused to create a new product would consist of those flaws as well.
Although this were true, if a component from a certain software product was to be reused in order to create a new product it could at times be used to fix
any lingering problems within the new product and improve the software quality as a whole.

\item An example of how a programming language can be an abstraction built on hardware is found within the assignment specifications. This is because when
we are given method specifications, we are required to write lines of python code within an IDE in which we are meant to compile and test the functionality
of our methods. When the code is compiled, the IDE will translate the python code into machine code in which hardware will then perform any specific task.
This is important because hardware only corresponds to machines code. Therefore, it is possible that a programming language can be an abstraction on top of
a hardware.

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for complex\_adt.py}

\noindent \lstinputlisting{../src/complex_adt.py}

\newpage

\section{Code for triangle\_adt.py}

\noindent \lstinputlisting{../src/triangle_adt.py}

\newpage

\section{Code for test\_driver.py}

\noindent \lstinputlisting{../src/test_driver.py}

\newpage

\section{Code for Partner's complex\_adt.py}

\noindent \lstinputlisting{../partner/complex_adt.py}

\section{Code for Partner's triangle\_adt.py}

\noindent \lstinputlisting{../partner/triangle_adt.py}

\end {document}
